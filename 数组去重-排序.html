<!DOCTYPE html>
<html>

	<head>
		<meta charset="UTF-8">
		<title>数组去重-排序</title>
	</head>

	<body>
	</body>

</html>

<script type="text/javascript">
	var a = ["23", "23", "2323", "233", "55", "23"];
	function deteRepeate(arr){
		var c=[];
		for(var i=0;i<arr.length;i++){
			var d=a[i];
			if(c.length==0){
				c.push(d);
			}
			else if(c.length>0){
				if(c.indexOf(d)==-1){
					c.push(d)
				}
			}
		}
		return c;
	}
	Array.prototype.unique=function(){
		var c=[];
		for(var i=0;i<this.length;i++){
			var d=this[i];
			if(c.length==0){
				c.push(d);
			}
			else if(c.length>0){
				if(c.indexOf(d)==-1){
					c.push(d)
				}
			}
		}
		return c;
	}
	var e=deteRepeate(a);
	console.log("e",e)
	console.log("a.unique()",a.unique())
	console.log("a",a);
	/*var c = [];
	for(var i = 0; i < a.length; i++) {
		var d=a[i];
		if(c.length==0){
			c.push(d);
		}
		else if(c.length>0){
			if(c.indexOf(d)==-1){
				c.push(d)
			}
		}
	}
	console.log(c)*/

//	function oSort(arr) {
//		var result = {};
//		var newArr = [];
//		for(var i = 0; i < arr.length; i++) {
//			if(!result[arr]) {
//				newArr.push(arr)
//				result[arr] = 1
//			}
//		}
//		return newArr
//	}
	
	/*
	1. Array.prototype.unique1 = function()
{
	var n = []; //一个新的临时数组
	for(var i = 0; i < this.length; i++) //遍历当前数组
	{
		//如果当前数组的第i已经保存进了临时数组，那么跳过，
		//否则把当前项push到临时数组里面
		if (n.indexOf(this[i]) == -1) n.push(this[i]);
	}
	return n;
}
2. Array.prototype.unique2 = function()
{
	var n = {},r=[]; //n为hash表，r为临时数组
	for(var i = 0; i < this.length; i++) //遍历当前数组
	{
		if (!n[this[i]]) //如果hash表中没有当前项
		{
			n[this[i]] = true; //存入hash表
			r.push(this[i]); //把当前数组的当前项push到临时数组里面
		}
	}
	return r;
}
3. Array.prototype.unique3 = function()
{
	var n = [this[0]]; //结果数组
	for(var i = 1; i < this.length; i++) //从第二项开始遍历
	{
		//如果当前数组的第i项在当前数组中第一次出现的位置不是i，
		//那么表示第i项是重复的，忽略掉。否则存入结果数组
		if (this.indexOf(this[i]) == i) n.push(this[i]);
	}
	return n;
}
根据hpl大牛的思路，我写了第四种方法：

Array.prototype.unique4 = function()
{
	this.sort();
	var re=[this[0]];
	for(var i = 1; i < this.length; i++)
	{
		if( this[i] !== re[re.length-1])
		{
			re.push(this[i]);
		}
	}
	return re;
}
    这个方法的思路是先把数组排序，然后比较相邻的两个值。 排序的时候用的JS原生的sort方法，JS引擎内部应该是用的快速排序吧。 最终测试的结

果是此方法运行时间平均是第二种方法的三倍左右，不过比第一种和第三种方法快了不少。

function deteRepeate(arr){
		var c=[];
		for(var i=0;i<arr.length;i++){
			var d=a[i];
			if(c.length==0){
				c.push(d);
			}
			else if(c.length>0){
				if(c.indexOf(d)==-1){
					c.push(d)
				}
			}
		}
		return c;
	} 
	*/
</script>